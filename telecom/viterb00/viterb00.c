/*==============================================================================
 *$RCSfile: viterb00.c,v $
 *
 *   DESC : Viterbi Decoder
 *
 *  EEMBC : Telecom Subcommittee 
 *
 * AUTHOR : yr
 *
 *    CVS : $Revision: 1.4 $
 *          $Date: 2002/06/14 16:31:59 $
 *          $Author: rick $
 *          $Source: d:/cvs/eembc2/telecom/viterb00/viterb00.c,v $
 *
 *          
 * NOTE   :
 *
 *------------------------------------------------------------------------------
 *
 * HISTORY :
 *
 * $Log: viterb00.c,v $
 * Revision 1.4  2002/06/14 16:31:59  rick
 * Bug #184-#187: Remove compiler warnings
 *
 * Revision 1.3  2002/04/01 20:52:05  administrator
 * Apply Standard Comment Block
 *
 * Revision 1.2  2002/02/18 23:51:53  rick
 * Completed Telocom TH_Lite conversion
 *
 *
 * 8/11/99 yr     1.0
 *       Initial coding for IS-136
 *
 *	5/20/00    arw
 *		Fixed defect/bug #126 to correct execution on 16-bit machines
 *		(actual fix is in this file).
 *
 *------------------------------------------------------------------------------
 * Copyright (c) 1998-2002 by the EDN Embedded Microprocessor 
 * Benchmark Consortium (EEMBC), Inc. 
 * 
 * All Rights Reserved. This is licensed program product and 
 * is owned by EEMBC. The Licensee understands and agrees that the 
 * Benchmarks licensed by EEMBC hereunder (including methods or concepts 
 * utilized therein) contain certain information that is confidential 
 * and proprietary which the Licensee expressly agrees to retain in the 
 * strictest confidence and to use only in conjunction with the Benchmarks 
 * pursuant to the terms of this Agreement. The Licensee further agrees 
 * to keep the source code and all related documentation confidential and 
 * not to disclose such source code and/or related documentation to any 
 * third party. The Licensee and any READER of this code is subject to 
 * either the EEMBC Member License Agreement and/or the EEMBC Licensee 
 * Agreement. 
 * TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, EEMBC DISCLAIMS ALL 
 * WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, 
 * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR 
 * PURPOSE, WITH REGARD TO THE BENCHMARKS AND THE ACCOMPANYING 
 * DOCUMENTATION. LICENSEE ACKNOWLEDGES AND AGREES THAT THERE ARE NO 
 * WARRANTIES, GUARANTIES, CONDITIONS, COVENANTS, OR REPRESENTATIONS BY 
 * EEMBC AS TO MARKETABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR OTHER 
 * ATTRIBUTES, WHETHER EXPRESS OR IMPLIED (IN LAW OR IN FACT), ORAL OR 
 * WRITTEN. 
 * 
 * Licensee hereby agrees by accessing this source code that all benchmark 
 * scores related to this code must be certified by ECL prior to publication 
 * in any media, form, distribution, or other means of conveyance of 
 * information subject to the terms of the EEMBC Member License Agreement 
 * and/or EEMBC Licensee Agreement. 
 * 
 * Other Copyright Notice (if any): 
 * 
 * For conditions of distribution and use, see the accompanying README file.
 * ===========================================================================*/

/*******************************************************************************
    Includes                                                                    
*******************************************************************************/

#include "algo.h"

/*
 * ViterbiDecoderIS136(EncodedStreamPtr, DecodedStreamPtr)
 *
 * Decode a packet of branch values generated by the 1/2 rate convolutional code 
 * as used in TIA/EIA IS-136.
 *
 * The generating polynomials are
 *		1+D+D3+D5
 *		1+D2+D3+D4+D5
 *
 * The input branch values are packed as two 3-bit values per polynomial,
 * in support of a soft decision implementation. Thus in each input word
 * only the six least significant bits contain meaningful information.
 * A 3-bit value of 0 indicates a strong 1 encoder input, and the value 7
 * indicates a strong 0 encoder input.
 * 
 * The output is packed, 16 bits to a word.
 *
 * The number of bits in the input packet is a compile-time constant.
 * The encoding of the packet is assumed to have started at state 0 and
 * to have been flushed back to state 0 when done.
 *
 * The decoder performs the ACS (Add/Compare/Select) function based on the 
 * received branch words and provides renormalization of the path metrics to
 * prevent overflow. When all branch words have been processed the decoder then
 * performs a Backtrack function to generate the data bits from the minimum
 * path metric and decoder trellis.
 */

/*
 * EVENMULTIPLEOF8: Indicates whether the number of bits in the encoded packet 
 * is an even multiple of 8. This is needed in the traceback, where decoded bits
 * are packed into 16-bit words (i.e. sets of 2*8 bits).
 */
#define		EVENMULTIPLEOF8		(1-(MAX_DATA_SIZE/8)%2)

/*
 * NUMSTATES: The number of states in the IS-136 decoder. A function of the
 * polynomials used by the convolutional encoder.
 * ENCBITS: The log2 of NUMSTATES.
 */
#define		ENCBITS			5
#define		NUMSTATES		(1<<ENCBITS)

/*
 * StatePathMetricData:
 */
typedef struct {
    e_s16 m_esState;
    e_s16 m_esPathMetric;
} StatePathMetricData;

static StatePathMetricData SPM1[NUMSTATES], SPM2[NUMSTATES];

static e_s16 pBranchMetrics[NUMSTATES/2];
/*
 * SavedPath: The traceback buffer.
 */
static e_s16 pSavedPath[NUMSTATES * (MAX_DATA_SIZE/8 + 1)];

/* 
 * BufPtr, BufSelector:
 *
 * Implement a double-buffering mechanism for SPM1, SPM2.
 * Each call to ACS and PreACS reads from one and writes to the other,
 * switching input and output on each call. The setting of which
 * of the two is input and which is output is determined by the
 * value of BufSelector, which toggles between 0 and 1.
 */
static StatePathMetricData *BufPtr[2] = {SPM1, SPM2};
static n_int BufSelector;

/*
 * FUNC: FindMetrics
 *
 * DESC: Input the branch value pair and compute the branch metrics.
 * The branch metrics are the scaled sum and difference of the branch values.
 *
 * Index into these tables is a value in the range 0-15.
 * 000 -> 0x4000	Strong 1
 * 001 -> 0x5000
 * 010 -> 0x6000
 * 011 -> 0x7000	Weak 1
 * 100 -> 0xa000	Weak 0
 * 101 -> 0xb000
 * 110 -> 0xc000
 * 111 -> 0xd000	Strong 0
 */
static e_s16 pBranchWordMapping[] = {
    16384, 20480, 24576, 28672,
    -24576, -20480, -16384, -12288,
};

static void FindMetrics(e_s16 EncodedWord, e_s16 *pBM)
{
    e_s16 esPp, esPm, esMm, esMp, esP016, esP116;
    e_s16 esBw0, esBw1;

    esBw0 = pBranchWordMapping[(EncodedWord & 0x38)>>3];
    esBw1 = pBranchWordMapping[EncodedWord & 0x7];
	/* fix for bug #126 arw */
	esP016 = (e_s16)( ( ((e_s32)esBw0 * -16)) >> 16);
	esP116 = (e_s16)( ( ((e_s32)esBw1 * -16)) >> 16);

    esPp =  esP016 + esP116;		/* Branch metric for recreated path 11 */
    esPm =  esP016 - esP116;		/* Branch metric for recreated path 10 */
    esMm = -esP016 - esP116;		/* Branch metric for recreated path 00 */
    esMp = -esP016 + esP116;		/* Branch metric for recreated path 01 */

    /* Populate the branch metrics table */
    *pBM++ = esMm;
    *pBM++ = esPm;
    *pBM++ = esMp;
    *pBM++ = esPp;
    *pBM++ = esPp;
    *pBM++ = esMp;
    *pBM++ = esPm;
    *pBM++ = esMm;
    *pBM++ = esMp;
    *pBM++ = esPp;
    *pBM++ = esMm;
    *pBM++ = esPm;
    *pBM++ = esPm;
    *pBM++ = esMm;
    *pBM++ = esPp;
    *pBM++ = esMp;
} /* FindMetrics */

/*
 * FUNC: PreACS
 *
 * DESC: Given that the encoder started from state 0, the first several state updates
 * can be made to update a smaller number of states, starting with 2 and multiplying
 * the number of states to be updated in each call. This results in reduced
 * computations for the decoder.
 */

static void PreACS(n_int Iterations, e_s16 *pBranchMetric)
{
    n_int i;
    e_s16 esMetricIn, esMetric1, esMetric2;

    StatePathMetricData *pIn1 = BufPtr[BufSelector];
    StatePathMetricData *pOut = BufPtr[1 - BufSelector];

    BufSelector ^= 1;		/* Toggle for next call */

    for (i = 0; i < Iterations; i++) {
	esMetricIn = *pBranchMetric++;

	esMetric1 = pIn1->m_esPathMetric - esMetricIn;
	esMetric2 = pIn1->m_esPathMetric + esMetricIn;

	pOut->m_esPathMetric = esMetric1;
	pOut->m_esState = (pIn1->m_esState << 1);
	pOut++;
	pOut->m_esPathMetric = esMetric2;
	pOut->m_esState = (pIn1->m_esState << 1)|1;
	pOut++;
	pIn1++;
    }
} /* PreACS */

/*
 * FUNC: ACS
 *
 * DESC: Updates the path metrics/paths for the Viterbi algorithm by
 * performing an add,compare,select update for state pairs.
 */
static void ACS(e_s16 *pBranchMetric)
{
    n_int i;
    e_s16 esMetricIn, esMetric1, esMetric2;

    StatePathMetricData *pIn1 = BufPtr[BufSelector];
    StatePathMetricData *pIn2 = pIn1 + NUMSTATES/2;
    StatePathMetricData *pOut = BufPtr[1 - BufSelector];

    BufSelector ^= 1;		/* Toggle for next call */

    for (i = 0; i < NUMSTATES/2; i++) {
	/* The Viterbi Butterfly */
	esMetricIn = *pBranchMetric++;

	esMetric1 = pIn1->m_esPathMetric - esMetricIn;
	esMetric2 = pIn2->m_esPathMetric + esMetricIn;

	if (esMetric1 >= esMetric2) {
	    pOut->m_esPathMetric = esMetric1;
	    pOut->m_esState = (pIn1->m_esState << 1);
	}
	else {
	    pOut->m_esPathMetric = esMetric2;
	    pOut->m_esState = (pIn2->m_esState << 1);
	}
	pOut++;

	esMetric1 = pIn1->m_esPathMetric + esMetricIn;
	esMetric2 = pIn2->m_esPathMetric - esMetricIn;

	if (esMetric1 >=esMetric2) {
	    pOut->m_esPathMetric =esMetric1;
	    pOut->m_esState = (pIn1->m_esState << 1) | 1;
	}
	else {
	    pOut->m_esPathMetric =esMetric2;
	    pOut->m_esState = (pIn2->m_esState << 1) | 1;
	}
	pOut++;

	pIn1++;
	pIn2++;
    }
} /* ACS */

/*
 *  FUNC: StorePaths
 *
 * DESC: Stores partial path metrics. 
 */
static void StorePaths(e_s16 *PathPtr)
{
    n_int i;
    e_s16 esPm;

    StatePathMetricData *pIn = BufPtr[BufSelector];

    for (i = 0; i < NUMSTATES; i++) {
	esPm = pIn->m_esState;
	*PathPtr++ = (esPm >> 5);	    /* Store path metric, leaving out current state */
	pIn->m_esState = (esPm & 0x1f);   /* Keep current state */
	pIn++;
    }
} /* StorePaths */

/*
 * FUNC: TraceBack
 *
 * DESC: Begin by taking the output path of the survivor state 0, 
 * and place its associated output path in memory as the last output data byte.
 * Then use bits 3-7 of that data as an offset pointer to the correct traceback
 * data of the previous path data memory.  Repeat until the beginning of the trace
 * is reached.
 * Taking state 0 as the starting point is based on the assumption that the
 * encoder ended the encoded block with a series of zeros (i.e. flushed to zero).
 */
static void TraceBack(e_s16 *pOut, e_s16 *pIn)
{
    n_int i;
    n_int offset = 0;
    volatile e_s16 PathBits1, PathBits2;	

    pOut += (MAX_DATA_SIZE / 8) / 2;			/* Point to last stage */
    *pIn =  (BufPtr[BufSelector])->m_esState;

    if (!EVENMULTIPLEOF8) {
	PathBits2 = *pIn;
	offset = (PathBits2 & 0xf8) >> 3;
	pIn -= NUMSTATES;

	*pOut-- = (PathBits2 << 8);
    }

    /* Process 16 bits in each iteration */
    for (i = 0; i < ((MAX_DATA_SIZE / 8) / 2); i++) {
	PathBits1 = *(pIn+offset);		/* Extract lower byte */
	offset = (PathBits1 & 0xf8) >> 3;
	pIn -= NUMSTATES;

	PathBits2 = *(pIn+offset);		/* Extract upper byte */
	offset = (PathBits2 & 0xf8) >> 3;
	pIn -= NUMSTATES;

	*pOut-- = (PathBits2 << 8) | PathBits1;	/* Store as 16-bit word */
    }
} /* TraceBack */

/*
 * FUNC: ViterbiDecoderIS136
 *
 * DESC: See documentation at top of this source file.
 */
void ViterbiDecoderIS136(e_s16 *EncodedStreamPtr, e_s16 *DecodedStreamPtr)
{
    n_int i;
    n_int iter;
    e_s16 *PathPtr = pSavedPath;

    /* Initialize the state path metric buffers */

    BufSelector = 0;			/* Start by reading from SPM1[] */
    SPM1[0].m_esPathMetric = 0x0ff;		/* Give state 0 higher metric */
    for (i = 1; i < NUMSTATES; i++) {
	SPM1[i].m_esPathMetric = 0;
    }

    iter = 1;
    for (i = 0; i < ENCBITS; i++) {
	FindMetrics(*EncodedStreamPtr++, pBranchMetrics);
	PreACS(iter, pBranchMetrics);
	iter *= 2;
    }

    for (i = 0; i < MAX_DATA_SIZE/8-1; i++) {
	n_int j;

	for (j = 0; j < 8; j++) {
	    FindMetrics(*EncodedStreamPtr++, pBranchMetrics);
	    ACS(pBranchMetrics);
	}
	StorePaths(PathPtr);
	PathPtr += NUMSTATES;
    }

    /* Process remaining bits */
    for (i = 0; i < 8-ENCBITS; i++) {
	FindMetrics(*EncodedStreamPtr++, pBranchMetrics);
	ACS(pBranchMetrics);
    }
    TraceBack(DecodedStreamPtr, PathPtr);
} /* ViterbiDecoderIS136 */

